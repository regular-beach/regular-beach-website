<!DOCTYPE html>
<html lang="en" id="top">
<head>
 
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="{{ url_for('static', filename='styles/new.css') }}" rel="stylesheet" />
    <link rel="stylesheet" href="https://use.typekit.net/ppt4ahi.css">
    <link rel="icon" type="image/svg+xml" href="{{ url_for('static', filename='favicon.svg') }}">
    <title>{% block title %}regular beach{% endblock %}</title>
</head>

{%extends "base.html"%}


{% block main %}


    <div class="title">(((rb)))26 <br>DRAW NOW!
    </div>

    <div class="controls">
  <button id="clearBtn">Clear</button>
  <button id="submitBtn">Submit</button>
</div>

<div id="message">
</div>

    <canvas id="canvas"></canvas>

<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
let drawing = false;

// Scale factor for high-DPI / Retina screens
const dpiScale = window.devicePixelRatio || 1;

// Make canvas full screen and handle retina
function resizeCanvas() {
  canvas.width = window.innerWidth * dpiScale;
  canvas.height = window.innerHeight * dpiScale;
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.scale(dpiScale, dpiScale);
}
resizeCanvas();
window.addEventListener("resize", resizeCanvas);

// Get mouse or touch position relative to canvas
function getPos(e) {
  const rect = canvas.getBoundingClientRect();
  const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
  const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;
  return { x, y };
}

function drawLine(pos) {
  ctx.lineWidth = 10 * dpiScale; // scale line thickness
  ctx.lineCap = "round";
  ctx.strokeStyle = "#000";
  ctx.lineTo(pos.x, pos.y);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(pos.x, pos.y);

  // subtle gritty effect
  const offsetFactor = 0.2;
  for (let i = 0; i < 2; i++) {
    const offsetX = (Math.random() - 0.5) * 2 * offsetFactor * dpiScale;
    const offsetY = (Math.random() - 0.5) * 2 * offsetFactor * dpiScale;
    ctx.beginPath();
    ctx.moveTo(pos.x + offsetX, pos.y + offsetY);
    ctx.lineTo(pos.x + offsetX, pos.y + offsetY);
    ctx.stroke();
  }
}

// ------------------ MOUSE EVENTS ------------------
canvas.addEventListener("mousedown", e => {
  drawing = true;
  const pos = getPos(e);
  ctx.beginPath();
  ctx.moveTo(pos.x, pos.y);
});

canvas.addEventListener("mouseup", () => drawing = false);
canvas.addEventListener("mouseleave", () => drawing = false);

canvas.addEventListener("mousemove", e => {
  if (!drawing) return;
  const pos = getPos(e);
  drawLine(pos);
});

// ------------------ TOUCH EVENTS ------------------
canvas.addEventListener("touchstart", e => {
  drawing = true;
  const pos = getPos(e);
  ctx.beginPath();
  ctx.moveTo(pos.x, pos.y);
});

canvas.addEventListener("touchmove", e => {
  if (!drawing) return;
  const pos = getPos(e);
  drawLine(pos);
  e.preventDefault(); // Prevent scrolling
});

canvas.addEventListener("touchend", () => drawing = false);
canvas.addEventListener("touchcancel", () => drawing = false);

// ------------------ CONTROLS ------------------

// Clear button
document.getElementById("clearBtn").onclick = () => {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.beginPath();
};

// Submit button
const message = document.getElementById("message");

document.getElementById("submitBtn").onclick = () => {
  const imgDataCheck = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const pixels = imgDataCheck.data;
  let isBlank = true;

  for (let i = 0; i < pixels.length; i += 4) {
    if (pixels[i + 3] !== 0) {
      isBlank = false;
      break;
    }
  }

  if (isBlank) {
    message.textContent = "draw";
    message.style.display = "block";
    setTimeout(() => { message.style.display = "none"; }, 2000);
    return;
  }

  const imgData = canvas.toDataURL("image/png");
  fetch("/submit_drawing", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ image: imgData })
  })
  .then(res => res.json())
  .then(data => {
    message.textContent = "thanks: " + data.filename;
    message.style.display = "block";
    setTimeout(() => { message.style.display = "none"; }, 2000);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.beginPath();
  })
  .catch(err => {
    message.textContent = "Error saving drawing.";
    message.style.display = "block";
    setTimeout(() => { message.style.display = "none"; }, 2000);
  });
};
</script>



{% endblock %}

{% include 'footer.html' %}


